"""
ðŸ’Ž Exercise-1: Two Sum
Write a function "two_sum(nums: list, target: int) -> tuple" that takes a list of integers
and a target integer. It should return a tuple of two indices whose elements add up to the target.
Assume that each input would have exactly one solution, and you may not use the same element twice.

Example:
two_sum([2, 7, 11, 15], 9) -> (0, 1)
"""


def two_sum(nums: list, target: int) -> tuple:
    sum = nums[0]
    for i in range(1, len(nums)):
        sum += nums[i]
        if sum == target:
            return (i-1, i)
        sum = nums[i]

# print(two_sum([1, 3], 4))


"""
ðŸ’Ž Exercise-2: Isomorphic Strings
Write a function "is_isomorphic(s: str, t: str) -> bool" that takes two strings s and t
and determines if they are isomorphic. Two strings s and t are isomorphic if the characters
in s can be replaced to get t, and all characters in s map to exactly one character in t and vice versa.

Example:
is_isomorphic('egg', 'add') -> True
"""


def is_isomorphic(s: str, t: str) -> bool:
    if len(s) != len(t):
        return False

    mapping_s_to_t = {}
    mapping_t_to_s = {}

    for char_s, char_t in zip(s, t):
        # Check mapping from s to t
        if char_s in mapping_s_to_t:
            if mapping_s_to_t[char_s] != char_t:
                return False
        else:
            mapping_s_to_t[char_s] = char_t

        # Check mapping from t to s
        if char_t in mapping_t_to_s:
            if mapping_t_to_s[char_t] != char_s:
                return False
        else:
            mapping_t_to_s[char_t] = char_s

    return True


# print(is_isomorphic('abcd', 'dcba'))
"""
ðŸ’Ž Exercise-3: Check Alien Dictionary
Write a function "is_alien_sorted(words: list, order: str) -> bool" that checks if words
are sorted lexicographicaly according to a new character order provided in the string order.

Example:
is_alien_sorted(["hello","leetcode"], "hlabcdefgijkmnopqrstuvwxyz") -> True
"""


def is_alien_sorted(words: list, order: str) -> bool:
    alien_dict = {char: i for i, char in enumerate(order)}

    def compare_words(word1, word2):
        for char1, char2 in zip(word1, word2):
            if alien_dict[char1] < alien_dict[char2]:
                return -1
            elif alien_dict[char1] > alien_dict[char2]:
                return 1

        # Check if one word is a prefix of the other
        if len(word1) < len(word2):
            return -1
        elif len(word1) > len(word2):
            return 1
        else:
            return 0

    # Check if the words are sorted according to the alien dictionary
    for i in range(1, len(words)):
        if compare_words(words[i-1], words[i]) > 0:
            return False

    return True


"""
ðŸ’Ž Exercise-4: Longest Substring Without Repeating Characters
Write a function "length_of_longest_substring(s: str) -> int" that takes a string s,
and returns the length of the longest substring without repeating characters.

Example:
length_of_longest_substring('abcabcbb') -> 3
"""


def length_of_longest_substring(s: str) -> int:
    prev = 0
    cnt = 1
    temp = [s[0]]
    for i in range(1, len(s)):
        if s[i] != s[i-1] and s[i] not in temp:
            cnt += 1
            temp.append(s[i])
        else:
            if cnt > prev:
                prev, cnt = cnt, 0
                temp = []

    return max(prev, cnt)


print(length_of_longest_substring('pwwkew'))

"""
ðŸ’Ž Exercise-5: Group Shifted Strings
Write a function "group_shifted(strings: list) -> list" that takes a
list of lowercase strings and groups all strings that are generated by shifting some letters
of another string circularly. Return a list of groups, each group is a list of strings.
Groups and strings within a group can be in any order.

Example:
group_shifted(["abc", "bcd", "acef", "xyz", "az", "ba", "a", "z"]) -> [["abc","bcd"],["acef"],["xyz"],["az","ba"],["a","z"]]
"""
def check_shifted(str1, str2):
    diff = ord(str2[0]) - ord(str1[0]) 
    for i in range(1, len(str1)):
        cur_diff = ord(str2[i]) - ord(str1[i])
        if cur_diff < 0:
            cur_diff = cur_diff + 26
            
        if cur_diff != diff:
            return False
    return True
        

def group_shifted(strings: list) -> list:
    res = []
    group = []
    for i in range(0, len(strings)):
        if len(group) < 1:
            group.append(strings[i])
            continue
        if len(strings[i]) != len(group[len(group)-1]):
            res.append(group)
            group = [strings[i]]
            continue
        if check_shifted(group[len(group)-1], strings[i]):
            group.append(strings[i])
            
    res.append(group)
    return res

# print(group_shifted(["abc", "bcd", "acef"]))
        
        
            
            
        
        
            
        
        
        
        
        
